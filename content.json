{"meta":{"title":"迷途小码农","subtitle":"尘世间迷途小码农一枚","description":"技术博客 IT JAVA 互联网","author":"Mini Chou","url":"https://minichou.github.io"},"pages":[{"title":"","date":"2017-03-24T06:17:16.672Z","updated":"2017-03-24T06:17:16.672Z","comments":true,"path":"404.html","permalink":"https://minichou.github.io/404.html","excerpt":"","text":"404 Oops! You're lost. We can not find the page you're looking for. Return home or try the search bar below."},{"title":"About","date":"2017-03-17T02:24:02.172Z","updated":"2017-03-17T02:24:02.172Z","comments":true,"path":"about/index.html","permalink":"https://minichou.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-03-17T02:24:02.173Z","updated":"2017-03-17T02:24:02.173Z","comments":true,"path":"categories/index.html","permalink":"https://minichou.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-03-17T02:24:02.175Z","updated":"2017-03-17T02:24:02.175Z","comments":true,"path":"tags/index.html","permalink":"https://minichou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo icarus主题小功能设置","slug":"Hexo-icarus主题小功能设置","date":"2016-04-29T03:05:56.000Z","updated":"2017-03-29T03:09:34.055Z","comments":true,"path":"2016/04/29/Hexo-icarus主题小功能设置/","link":"","permalink":"https://minichou.github.io/2016/04/29/Hexo-icarus主题小功能设置/","excerpt":"添加站长统计我们通过站长统计来及时查看我们个人网站的浏览情况。首先，我们需要进行注册：站长统计以下参考：添加cnzz站长统计","text":"添加站长统计我们通过站长统计来及时查看我们个人网站的浏览情况。首先，我们需要进行注册：站长统计以下参考：添加cnzz站长统计 在theme的_config.yml中的末尾添加以下：(这部很重要，不添加web_id将无法显示出来)12# CNZZ idcnzz: 这里填入你在站长统计注册后的web_id 在目录：主题的layout/_partial/添加文件为cnzz.ejs，内容如下：123&lt;% if (theme.cnzz)&#123; %&gt;Analyse with &lt;script src=\"https://s4.cnzz.com/z_stat.php?id=&lt;%= theme.cnzz %&gt;&amp;web_id=&lt;%= theme.cnzz %&gt;\" language=\"JavaScript\"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 注意:一定要采用https方式引入，否则chrome浏览器考虑安全性问题不会加载 最后进行显示，在路径layout/_partial/footer.ejs里面添加： 1...PPOffice&lt;/a&gt;.&lt;%- partial(&apos;cnzz&apos;) %&gt; 再次提醒注意在_config.xml中添加web_id，否则无法显示。当显示出来了，又有一个问题，那就是要填写查看密码了。查看以下即可：【设置】如何设置查看密码？（此功能只限站长用户） 百度/谷歌验证站点为什么要验证站点了，因为要搜索引擎进行收录，说白了就是让别人更容易搜索到你的网站，仅此而已。首先需要到百度/谷歌站长统计中注册，以及验证：Google网站管理员工具地址百度站长工具注册完后，进行输入相应的网站地址，然后选择html验证，将代码加入以下路径layout/_partial/head.ejs：（截取部分） 12345&lt;head&gt; &lt;meta name=\"baidu-site-verification\" content=\"tqvy7RDErf\" /&gt; &lt;meta name=\"google-site-verification\" content=\"hjN29-PO_KfE-dgow-7hcz75xJj0qzZ6G2OkXZ3FVd8\" /&gt; &lt;meta charset=\"utf-8\"&gt; .... 然后发布到github中，再进行验证即可。 百度分享按钮https站点不显示问题在主题中设置百度分享按钮之后发现一个问题，就是部署到github page之后不显示，但本地测试可以。之后F12调试，发现百度分享采用的是http，而github page则是https，chrome浏览器考虑安全问题，不允许加载导致线上百度分享按钮脚本未能加载。 解决方案要让https站点加载，很简单，将百度分享脚本存放到可支持https的站点即可。这里我直接将百度分享脚本放到hexo的source目录下（hexo根目录的source下或者主题的source下都可以） 百度分享脚本可在一下地址下载：百度分享脚本下载之后解压，将static文件夹复制到source目录下即可。 然后找到主题中引用百度分享脚本的地方，我用的是icarus主题，则在themes\\icarus\\layout\\share目录下的bdshare.ejs文件。修改改文件：123.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 以上步骤完成，搞定。 参考百度分享集成 百度分享不支持Https的解决方案","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://minichou.github.io/categories/杂谈/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://minichou.github.io/tags/hexo/"}]},{"title":"缓存穿透及雪崩之常见解决方案","slug":"缓存穿透及雪崩之常见解决方案","date":"2016-04-20T07:33:49.000Z","updated":"2017-03-29T08:14:11.768Z","comments":true,"path":"2016/04/20/缓存穿透及雪崩之常见解决方案/","link":"","permalink":"https://minichou.github.io/2016/04/20/缓存穿透及雪崩之常见解决方案/","excerpt":"缓存穿透什么叫缓存穿透缓存穿透：简而言之就是查询缓存系统和后端系统都不存在的数据。如果这类查询并发量很大，将会对后端存储系统造成很大压力。","text":"缓存穿透什么叫缓存穿透缓存穿透：简而言之就是查询缓存系统和后端系统都不存在的数据。如果这类查询并发量很大，将会对后端存储系统造成很大压力。 如何避免缓存穿透造成缓存穿透根本原因：空查询。前端系统不知道所查数据到底存不存在，导致不必要查询。造成空查询的原因主要有两个： 代码设计或数据出现问题 恶意攻击 如何解决空查询呢？避免查库有两个条件： 缓存命中，则不需要查库 事先知道库中不存在，则不需要查库 解决方案针对第一个条件 缓存空值 如果查询数据库不存在，我们之前的操作就不会进行缓存，这里我们仍然缓存空对象。之后再访问这个数据将会从缓存中获取，保护了后端数据源。缓存空对象会有两个问题： 空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。 缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。 注意：采用缓存空值策略，只能避免第二次空查询，第一次还是会进行查库操作。 针对第二个条件 bloom filter（布隆过滤器） 根据存储层数据构建布隆过滤器，在进行查询操作之前先通过bloom filter判断是否存在，如果存在则继续查询操作，不存在，则直接返回，避免空查询。采用布隆过滤器可能会存在以下问题： 占用部分内存空间，因为要将数据库中的数据全量构造出一个bitmap 存在误判的情况，比如某个key对应的数据其实不存在，但通过bloomfilter判断结果可能存在，这时只需进行一次查库操作，毕竟这种误判率比较低。 无法删除：即使数据库中删除该数据，也无法将其从bloomfilter中删除，只能重新构建。 使用场景：缓存命中率不高，如下场景： 电商客户咨询场景：系统查询最近咨询客服分配给改客户，如无，则随机分配，且这里客户-&gt;最近咨询客服对应信息只存储7天。这类场景缓存命中率不高。 电商商品推荐场景：针对老用户，系统根据用户购买记录进行商品推荐，新用户则没有。用户登录网站系统查询是否存在推荐数据场景，命中率不高。 缓存雪崩什么叫缓存雪崩缓存雪崩: 简而言之就是缓存不可用或失效，导致所有的查询操作都落到后端存储系统，对后端存储系统造成很大压力，严重时可能会冲垮存储系统，产生连锁反应，最终导致服务不可用。 如何防止雪崩发生要避免缓存雪崩，首先要清楚雪崩产生的根本原因：所有缓存在同一个时间段同时失效或不可用，导致同一时间所有查询操作都落到存储层。避免过多查库请求有两个条件： 不要让缓存在同一时间段失效即始终有部分缓存可能 控制查库请求，只允许少量查库操作 解决方案针对以上两个条件在业务代码层面可采取以下策略： 针对不同key设置不同失效时间，尽量将失效时间打散，不要聚集在一个时间段 采取二级缓存策略：同一个数据，缓存两次，分别设置不同的失效时间，这样即使其中一个缓存失效，另一个仍然可用，注意：数据更新时要同时处理两个缓存。 采用加锁或队列控制查库线程数。在缓存失效后，控制真正查库线程数。让一部分线程去查库，获取之后，存入缓存，后续查询直接从缓存获取。 缓存预加载。在系统提供服务之前进行热点key缓存预加载，不至于系统启动之初，由于缓存还没存放，导致所有请求达到后端系统。 缓存永不过期即不设置过期时间：不建议使用，1.造成数据不一致，2.浪费存储空间，可能会造成内存溢出。 在缓存系统架构层面，则尽量采用集群多副本方式保证缓存服务高可用，如redis可采用Redis Sentinel或者Redis Cluster保证缓存服务高可用。","categories":[{"name":"redis","slug":"redis","permalink":"https://minichou.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://minichou.github.io/tags/redis/"},{"name":"缓存穿透","slug":"缓存穿透","permalink":"https://minichou.github.io/tags/缓存穿透/"},{"name":"缓存雪崩","slug":"缓存雪崩","permalink":"https://minichou.github.io/tags/缓存雪崩/"}]},{"title":"Redis Sentinel原理","slug":"Redis Sentinel原理","date":"2016-03-25T09:49:28.000Z","updated":"2017-03-29T02:06:24.685Z","comments":true,"path":"2016/03/25/Redis Sentinel原理/","link":"","permalink":"https://minichou.github.io/2016/03/25/Redis Sentinel原理/","excerpt":"本文将主要分析redis sentinel模式中sentinel（哨兵）所起作用 Sentinel主要功能sentinel主要功能是在主库（master）出现问题后，实现：master存活检测、主从运行情况检测、自动failover、主从切换等高可用。redis的sentinel最小配置是一主一从，实现故障转移高可用。","text":"本文将主要分析redis sentinel模式中sentinel（哨兵）所起作用 Sentinel主要功能sentinel主要功能是在主库（master）出现问题后，实现：master存活检测、主从运行情况检测、自动failover、主从切换等高可用。redis的sentinel最小配置是一主一从，实现故障转移高可用。 基本原理：投票算法+心跳机制 在哨兵的运行阶段，其会向其他的哨兵、master和slave发送消息确认其是否存活，如果在指定的时间内未收到正常回应，暂时认为对法挂起了（被标记为主观宕机–SDOWN）当多个哨兵都报告同一个master没有响应了，通过投票算法，系统判断其已死亡（被标记为客观宕机–ODOWN）。在已知的slave节点中，根据实际情况和优先级从该下线的master所属slave中选出一个slave提升为新的master，其他的slave都指向这个新的master，继续维护主从关系。 redis的sentinel系统可以用来管理多个redis服务器，该系统可以执行以下三个任务： 监控：sentinel会不断的检查你的主服务器和从服务器是否正常运行。 提醒：当被监控的某个redis服务器出现问题，sentinel通过API向管理员或者其他的应用程序发送通知。自动故障转移：当主服务器不能正常工作时，sentinel会开始一次自动的故障转移操作，它会将与失效主服务器是主从关系的其中一个从库升级为新的主服务器，并且修改其他的的slave，重定向到新的slave。 redis的sentinel是一个分布式系统，可以在一个架构下运行多个sentinel进程，这些进程之间通过流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从slave服务器作为新的主服务器。 关于redis sentinel的主观下线和客观下线redis sentinel关于被监控的redis实例出现不响应的判断，内部有两种不同的概念：主观下线和客观下线 主观下线：当只有单个sentinel实例对redis实例做出无响应的判断，此时进入主观判断，不会触发自动故障转移等操作。注意，一个服务器必须在 master-down-after-milliseconds 毫秒内， 一直返回无效回复才会被 Sentinel 标记为主观下线。 客观下线：多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线） 从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了流言协议： 如果 Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。 客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。 Sentinel定时执行的操作 每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。 如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。 如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。 在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。 当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。 自动发现哨兵（sentinel）和从服务器sentinel与sentinel之间可以进行信息交换和检测对方的可用性。 无需为运行的每个sentinel分别设置其他的sentinel地址，因为sentinel可以通过redis内部的发布\\订阅功能来自动的发现正在监视相同主机服务器的其他sentinel，这个功能是通过 sentinel:hello发送消息来实现的。 不必列出所有slave的信息，因为sentinel可以通过询问主服务器获取从服务器信息。 每个 Sentinel 会以每两秒一次的频率， 通过发布与订阅功能， 向被它监视的所有主服务器和从服务器的 sentinel:hello 频道发送一条信息， 信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。 每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 sentinel:hello 频道， 查找之前未出现过的 sentinel （looking for unknown sentinels）。 当一个 Sentinel 发现一个新的 Sentinel 时， 它会将新的 Sentinel 添加到一个列表中， 这个列表保存了 Sentinel 已知的， 监视同一个主服务器的所有其他 Sentinel 。 Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。 在将一个新 Sentinel 添加到监视主服务器的列表上面之前， Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel Sentinel执行failover流程 sentinel发现master下线，修改其状态为sdown； sentinel和其他sentinel确认master是否down掉，确认其状态为odown； 对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选(即首先发现master down掉的sentinel有优先权当选为leader)； 如果当选失败，那么在设定的故障迁移超时时间的两倍之后，重新尝试当选。如果当选成功，那么执行以下步骤； 选出一个从服务器，并将它升级为主服务器； leader选出一个slave作为master，发送slaveof no one命令； 通过发布与订阅功能，将更新后的配置传播给所有其他 Sentinel，其他 Sentinel 对它们自己的配置进行更新； 并通过给其他slave发送slaveof master命令告知其他slave新的master； 当所有从服务器都已经开始复制新的主服务器时，领头Sentinel终止这次故障迁移操作。 Sentinel发出投票通知发现一个master down掉的sentinel发出投票请求的时候，接收者依据epoch进行判断后并返回它认为的leader后，发现者对接收者的意见照单全收，并没有进行“反驳”。换句话说，接收者接收所有的接收者的意见后，并没有进行一番比较，就接收了每个接收者的认为的leader，结果其leader就是最后一个接收者认为的leader。 但是从另一方面说，每个接收者都会收到所有潜在的leader的选举邀请，他们会对所有这些候选者进行比较一番后，本地的leader肯定是最后比较的结果，这个结果会通过反馈给每个候选者的通知，使他们知道最终的胜出者，所以还是能选举出最后的leader。 Sentinel领头羊选举Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。 这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。 更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。 简单来说， 我们可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。 举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。 如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。 Sentinel主master选举Sentinel 使用以下规则来选择新的主服务器： 在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。 在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。 Sentinel与redis实例之间的通信以下是sentinel节点所接受的命令： PING ：返回 PONG 。 SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。 SENTINEL slaves ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。 SENTINEL get-master-addr-by-name ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号。 SENTINEL reset ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清除主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。 SENTINEL failover ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。 sentinel连接一个redis实例的时候，会创建cmd和pub/sub两个链接，cmd连接创建成功时候立即发送一个ping命令，pub/sub连接创建成功的时候立即去监听hello channel。通过cmd连接给redis发送命令，通过pub/sub连接得到redis实例上的其他sentinel实例。sentinel与maste/slave的交互主要包括： PING:sentinel向其发送PING以了解其状态（是否下线） INFO:sentinel向其发送INFO以获取replication相关的信息，通过这个命令可以获取master的slaves PUBLISH:sentinel向其监控的master/slave发布本身的信息及master相关的配置 SUBSCRIBE:sentinel通过订阅master/slave的”sentinel:hello“频道以获取其它正在监控相同服务的sentinels sentinel与sentinel的交互主要包括： PING:sentinel向slave发送PING以了解其状态（是否下线） SENTINEL is-master-down-by-addr：和其他sentinel协商master状态，如果master odown，则投票选出leader做fail over Sentinel配置文件参数说明部分参数说明：port ：sentinel实例之间通讯的端口 dir :指定工作目录 sentinel monitor：sentinel需要监控的主库信息 sentinel monitor其中master-name为自定义master名称，ip为master所在主机的ip地址，redis-port为redis实例的端口号，quorum界定有多少个sentinel实例提交与master通信失败才会判断master为客观宕机（ODOWN），从而发起自动切换。 sentinel auth-pass：如果master开启的密码验证，在这里配置master的密码 sentinel auth-pass sentinel down-after-milliseconds：master被当前sentinel判断为失效的时间间隔，sentinel与master之间的通信没有响应或者代码错误等超过这个时间限定，sentinel会判断master为客观宕机SDOWNdown-after-millisecondssentinel parallel-syncs：当自动切换完成后，同时进行slaveof到新的master并行执行SYNC的slave个数，默认为1，建议线上保留这个数字，在slave执行slaveof的时候，将不会对客户端请求进行响应，对于读写分离业务会有一定的影响sentinel parallel-syncs sentinel failover-timeout：制定failover的过期时间，超过此时间没有触发任何的failover操作，当前的sentinel会认为此次的failover擦走哦失败。 sentinel failover-timeout sentinel notification-script ：当进行failover时，可以指定一个通知脚本用来通知系统管理员，当前集群的情况。脚本被允许执行的最大时间为60秒，超过这个时间，脚本会被kill。 sentinel notification-script 稍后重试，最大重试次数为10; 执行结束，无需重试 sentinel client-reconfig-script：failover之后重配置客户端，执行脚本时会传递大量参数，请参考相关文档","categories":[{"name":"redis","slug":"redis","permalink":"https://minichou.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://minichou.github.io/tags/redis/"},{"name":"sentinel原理","slug":"sentinel原理","permalink":"https://minichou.github.io/tags/sentinel原理/"}]},{"title":"Redis Sentinel（哨兵模式）高可用集群搭建及Spring集成","slug":"Redis Sentinel（哨兵模式）高可用集群搭建及Spring集成","date":"2016-03-23T09:42:36.000Z","updated":"2017-03-29T07:33:19.472Z","comments":true,"path":"2016/03/23/Redis Sentinel（哨兵模式）高可用集群搭建及Spring集成/","link":"","permalink":"https://minichou.github.io/2016/03/23/Redis Sentinel（哨兵模式）高可用集群搭建及Spring集成/","excerpt":"本文将介绍如何通过Sentinel实现Redis集群(主从)的高可用方案，该方案需要使用Jedis2.2.2及以上版本（强制），Redis2.8及以上版本(可选，Sentinel最早出现在Redis2.4中，Redis2.8中Sentinel更加稳定)，同时将redis与spring-date-redis集成。 一、Sentinel介绍Sentinel是Redis的高可用性（HA）解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器故障时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。Redis提供的sentinel（哨兵）机制，通过sentinel模式启动redis后，自动监控master/slave的运行状态，基本原理是：心跳机制+投票裁决 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器选举出来，升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。","text":"本文将介绍如何通过Sentinel实现Redis集群(主从)的高可用方案，该方案需要使用Jedis2.2.2及以上版本（强制），Redis2.8及以上版本(可选，Sentinel最早出现在Redis2.4中，Redis2.8中Sentinel更加稳定)，同时将redis与spring-date-redis集成。 一、Sentinel介绍Sentinel是Redis的高可用性（HA）解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器故障时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。Redis提供的sentinel（哨兵）机制，通过sentinel模式启动redis后，自动监控master/slave的运行状态，基本原理是：心跳机制+投票裁决 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器选举出来，升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 二、Sentinel的主从原理以下为Sentinel架构以及主从切换图： Jedis2.2.2之前版本，因为主从实例地址(IP PORT)是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在Jedis2.2.2中新增了对Sentinel的支持，应用通过redis.clients.jedis.JedisSentinelPool.getResource()取得的Jedis实例会及时更新到新的主实例地址。 三、Redis Sentinel高可用集群搭建首先稍微介绍下如何在linux上安装redis redis安装1234$ wget http://download.redis.io/releases/redis-3.2.8.tar.gz$ tar xzf redis-3.2.8.tar.gz$ cd redis-3.2.8$ make 测试：首先启动redis服务1fish@test-vm:~/server/redis-3.2.8$ src/redis-server 然后打开一个新的命令窗口，启动redis client端进行测试。12345fish@test-vm:~/server/redis-3.2.8$ src/redis-cli 127.0.0.1:6379&gt; set name fishOK127.0.0.1:6379&gt; get name\"fish\" redis sentinel集群搭建硬件条件有限，这里我将采用伪分布式进行搭建，所有节点都在同一台虚拟机，通过不同端口区分：2个哨兵，1个主redis，2个从redis首先在redis目录创建conf目录，然后在其中添加一下配置文件，配置文件如下： 123456fish@test-vm:~/server/redis-3.2.8/conf$ ls -1redis-master-6379.confredis-slave-6380.confredis-slave-6381.confsentinel-63791.confsentinel-63792.conf redis节点配置可通过复制redis目录下的redis.conf默认配置进行相应修改，sentinel节点的配置文件则可通过复制redis目录下的sentinel.conf配置内容进行相应修改。sentinel_63791.conf 配置：123456789port 63791daemonize yeslogfile \"/var/log/sentinel_63791.log\"#master-1sentinel monitor master-1 192.168.78.99 6379 2sentinel down-after-milliseconds master-1 5000sentinel failover-timeout master-1 18000sentinel auth-pass master-1 yingjunsentinel parallel-syncs master-1 1 sentinel_63792.conf 配置：123456789port 63792daemonize yeslogfile \"/var/log/sentinel_63792.log\"#master-1sentinel monitor master-1 192.168.78.99 6379 2sentinel down-after-milliseconds master-1 5000sentinel failover-timeout master-1 18000sentinel auth-pass master-1 yingjunsentinel parallel-syncs master-1 1 redis_master_6379.conf 配置：在原配置文件中作如下修改：1234port 6379daemonize yesrequirepass yingjunmasterauth yingjun redis_slave_6380.conf 配置：在原配置文件中作如下修改：12345port 6380daemonize yesrequirepass yingjunslaveof 192.168.78.99 6379masterauth yingjun redis_slave_6381.conf 配置：在原配置文件中作如下修改：12345port 6381daemonize yesrequirepass yingjunslaveof 192.168.78.99 6379masterauth yingjun 按如下顺序依次启动服务：12345./redis-server ../conf/redis_master_6379.conf./redis-server ../conf/redis_slave_6381.conf ./redis-server ../conf/redis_slave_6382.conf ./redis-sentinel ../conf/sentinel_63791.conf./redis-sentinel ../conf/sentinel_63792.conf 查看进程是否都已经启动： 1234567fish@test-vm:~$ ps -ef|grep redisfish 30233 2408 0 15:23 ? 00:00:03 src/redis-server *:6379fish 30257 2408 0 15:24 ? 00:00:03 src/redis-server *:6380fish 30270 2408 0 15:24 ? 00:00:03 src/redis-server *:6381fish 30503 2408 0 16:06 ? 00:00:00 src/redis-sentinel *:63791 [sentinel]fish 30514 2408 0 16:06 ? 00:00:00 src/redis-sentinel *:63792 [sentinel]fish 30549 8143 0 16:09 pts/18 00:00:00 grep --color=auto redis 查看master的状态：1234567891011121314151617fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 637910.14.137.85:6379&gt; set name tom(error) NOAUTH Authentication required.10.14.137.85:6379&gt; auth fish@123OK10.14.137.85:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=10.14.137.85,port=6380,state=online,offset=66732,lag=1slave1:ip=10.14.137.85,port=6381,state=online,offset=66732,lag=1master_repl_offset:66871repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:6687010.14.137.85:6379&gt; 可以看到role为master，同时显示了旗下有两个slave通过src/redis-cli -h 10.14.137.85 -p 6379命令登录master客户端，如何redis设置了password，此时可以进入，但是不能进行操作，需通过autho password命令授权后，在可进行其他操作。也可登录时加上-a password参数指定密码。 查看slave的状态：1234567891011121314151617181920212223fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 638010.14.137.85:6380&gt; get name(error) NOAUTH Authentication required.10.14.137.85:6380&gt; auth fish@123OK10.14.137.85:6380&gt; info replication# Replicationrole:slavemaster_host:10.14.137.85master_port:6379master_link_status:upmaster_last_io_seconds_ago:0master_sync_in_progress:0slave_repl_offset:84567slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:010.14.137.85:6380&gt; 可以看到role为slave，只读不能写 查看sentinel的状态：1234fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379110.14.137.85:63791&gt; info sentinelDENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. 3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.10.14.137.85:63791&gt; 从以上输出可以发现，竟然出错了，仔细查看输出信息，说是redis运行在保护模式protected-mode 是为了禁止公网访问redis cache，加强redis安全的。它启用的条件，有两个： 没有bind IP 没有设置访问密码 如果启用了，则只能够通过lookback ip（127.0.0.1）访问Redis cache，如果从外网访问，则会返回相应的错误信息，就是上图中的信息。因此在新的版本中，应该配置绑定IP和访问密码，这样的话才不会报错误这里master及两台slave redis由于设置了pass，所以不会提示，但sentinel既没设置pass也没绑定ip，所以连接sentinel时出现以上提示，解决方案： 更改配置文件，将protected-mode设置为no 通过命令关闭保护模式：CONFIG SET protected-mode no 重启服务，启动时加上参数：–protected-mode no 绑定ip或设置pass 采取其中一种即可。ok后，查看sentinel状态：12345678910fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379110.14.137.85:63791&gt; info sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=master-1,status=ok,address=10.14.137.85:6379,slaves=2,sentinels=210.14.137.85:63791&gt; 接下来验证redis sentinel的主从切换： 首先关闭主redis（6379）服务（shutdown）。查看哨兵，发现端口号为6380的从服务变成了主服务,sentinel自动完成了故障切换。1234567891011fish@test-vm:~/server/redis-3.2.8$ kill -9 31013fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379110.14.137.85:63791&gt; info sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=master-1,status=ok,address=10.14.137.85:6380,slaves=2,sentinels=210.14.137.85:63791&gt; 可以看到哨兵所监听的master address变成了address=10.14.137.85:6380 启动刚才被shutdown的6379服务并查看，发现它变成了从服务。 12345678910111213141516fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 638010.14.137.85:6380&gt; info replicationNOAUTH Authentication required.10.14.137.85:6380&gt; auth fish@123OK10.14.137.85:6380&gt; info replication# Replicationrole:masterconnected_slaves:1slave0:ip=10.14.137.85,port=6381,state=online,offset=22085,lag=0master_repl_offset:22085repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:2208410.14.137.85:6380&gt; 可见，之前的slave变成了master重新启动之前的master：1234567891011121314151617181920fish@test-vm:~/server/redis-3.2.8$ src/redis-server conf/redis-master-6379.conf fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379 -a fish@12310.14.137.85:6379&gt; info replication# Replicationrole:slavemaster_host:10.14.137.85master_port:6380master_link_status:upmaster_last_io_seconds_ago:1master_sync_in_progress:0slave_repl_offset:46407slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:010.14.137.85:6379&gt; 发现之前的master下线重启之后role变为了slave。 四、Jedis Sentinel教程Maven依赖：1234567891011&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; redis的配置文件：123456789101112#redis configredis.pass=yingjunredis.pool.maxTotal=105redis.pool.maxIdle=10redis.pool.maxWaitMillis=60000redis.pool.testOnBorrow=truesentinel1.ip=192.168.78.99sentinel1.port=63791sentinel2.ip=192.168.78.99sentinel2.port=63792 Spring的配置文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- Redis 配置 --&gt; &lt;!--//jedis 连接池配置--&gt; &lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.pool.maxTotal&#125;\"/&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.pool.maxIdle&#125;\"/&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.pool.maxWaitMillis&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.pool.testOnBorrow&#125;\"/&gt; &lt;/bean&gt; &lt;!--redis sentinel集群 节点信息配置--&gt; &lt;bean id=\"sentinelConfiguration\" class=\"org.springframework.data.redis.connection.RedisSentinelConfiguration\"&gt; &lt;property name=\"master\"&gt; &lt;bean class=\"org.springframework.data.redis.connection.RedisNode\"&gt; &lt;property name=\"name\" value=\"master-1\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=\"sentinels\"&gt; &lt;set&gt; &lt;bean class=\"org.springframework.data.redis.connection.RedisNode\"&gt; &lt;constructor-arg name=\"host\" value=\"$&#123;sentinel1.ip&#125;\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"port\" value=\"$&#123;sentinel1.port&#125;\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.data.redis.connection.RedisNode\"&gt; &lt;constructor-arg name=\"host\" value=\"$&#123;sentinel2.ip&#125;\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"port\" value=\"$&#123;sentinel2.port&#125;\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Jedis ConnectionFactory连接配置 --&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"password\" value=\"$&#123;redis.pass&#125;\"/&gt; &lt;property name=\"poolConfig\"&gt; &lt;ref bean=\"jedisPoolConfig\"/&gt; &lt;/property&gt; &lt;constructor-arg name=\"sentinelConfig\" ref=\"sentinelConfiguration\"/&gt; &lt;/bean&gt; &lt;!-- redisTemplate配置，redisTemplate是对Jedis的对redis操作的扩展，有更多的操作，封装使操作更便捷 --&gt; &lt;!--通用redisTemplate 指定序列化器--&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"/&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;/property&gt; &lt;property name=\"hashKeySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;/property&gt; &lt;!--如果value采用jdk自带序列化处理器，则需要序列号的对象必须实现Serializable--&gt; &lt;property name=\"valueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/&gt; &lt;/property&gt; &lt;property name=\"hashValueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--专门处理String类型的key-value--&gt; &lt;bean id=\"stringRedisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 代码中直接用redisTemplate调用：12345678910111213141516@Overridepublic boolean add(final KeyToken tkey) &#123; boolean result = redisTemplate.execute(new RedisCallback&lt;Boolean&gt;() &#123; @Override public Boolean doInRedis(RedisConnection connection) throws DataAccessException &#123; RedisSerializer&lt;String&gt; serializer = getRedisSerializer(); byte[] key = serializer.serialize(tkey.getIndex()); byte[] name = serializer.serialize(tkey.getExpire_time()); return connection.setNX(key, name); &#125; &#125;); return result;&#125; 以下是测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.zxy.lab.code.redis;import com.google.gson.Gson;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataAccessException;import org.springframework.data.redis.connection.RedisConnection;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import java.io.Serializable;import java.util.Date;/** * Created by cdzhouxiaoyu@jd.com on 2017/3/28. */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:spring-config.xml\")public class SentinelRedisTest &#123; @Resource(name = \"stringRedisTemplate\") private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Test public void testPutCache() &#123; String key = \"redis-test\"; ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue(); valueOperations.set(key, \"hello\"); System.out.println(valueOperations.get(key));// hello &#125; @Test public void testPutObject() &#123; String key = \"redis-test-order\"; Order order = new Order(1234L, 100, new Date()); ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue(); valueOperations.set(key, order); System.out.println(valueOperations.get(key));// Order&#123;orderId=1234, price=100.0, submitTime=Tue Mar 28 17:51:56 CST 2017&#125; &#125; @Test public void testPutObjectByStringRedisTemplate() &#123; final String key = \"redis-test-order\"; final Order order = new Order(1234L, 100, new Date()); Boolean result = stringRedisTemplate.execute(new RedisCallback&lt;Boolean&gt;() &#123; @Override public Boolean doInRedis(RedisConnection redisConnection) throws DataAccessException &#123; // 先将对象转换为json字符串，再采用StringSerializer。可知，这里可以自定义序列号方式，比如采用Protostuff序列号对象 RedisSerializer&lt;String&gt; stringSerializer = redisTemplate.getStringSerializer(); byte[] k = stringSerializer.serialize(key); byte[] v = stringSerializer.serialize(new Gson().toJson(order)); return redisConnection.setNX(k, v); &#125; &#125;); Object value = stringRedisTemplate.execute(new RedisCallback&lt;Object&gt;() &#123; @Override public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123; RedisSerializer&lt;String&gt; stringSerializer = redisTemplate.getStringSerializer(); byte[] v = redisConnection.get(stringSerializer.serialize(key)); String valueStr = stringSerializer.deserialize(v); return new Gson().fromJson(valueStr, Order.class); &#125; &#125;); System.out.println(value); //Order&#123;orderId=1234, price=100.0, submitTime=Tue Mar 28 18:18:40 CST 2017&#125; &#125; public static class Order implements Serializable&#123; private Long orderId; private double price; private Date submitTime; public Order() &#123; &#125; public Order(Long orderId, double price, Date submitTime) &#123; this.orderId = orderId; this.price = price; this.submitTime = submitTime; &#125; public Long getOrderId() &#123; return orderId; &#125; public void setOrderId(Long orderId) &#123; this.orderId = orderId; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public Date getSubmitTime() &#123; return submitTime; &#125; public void setSubmitTime(Date submitTime) &#123; this.submitTime = submitTime; &#125; @Override public String toString() &#123; return \"Order&#123;\" + \"orderId=\" + orderId + \", price=\" + price + \", submitTime=\" + submitTime + '&#125;'; &#125; &#125;&#125; 常见问题以下是测试过程中遇到的问题： 测试工程启动时报如下错误： java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter 详细错误信息如下：123456789101112131415161718192021222324Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;redisTemplate&apos; defined in class path resource [spring/spring-redis.xml]: Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.&lt;init&gt;(Ljava/lang/ClassLoader;)V at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1514) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:293) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:290) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:191) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:638) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482) at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:120) at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60) at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:102) at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:246) at org.springframework.test.context.CacheAwareContextLoaderDelegate.loadContextInternal(CacheAwareContextLoaderDelegate.java:69) at org.springframework.test.context.CacheAwareContextLoaderDelegate.loadContext(CacheAwareContextLoaderDelegate.java:95) ... 29 moreCaused by: java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.&lt;init&gt;(Ljava/lang/ClassLoader;)V at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.&lt;init&gt;(JdkSerializationRedisSerializer.java:54) at org.springframework.data.redis.core.RedisTemplate.afterPropertiesSet(RedisTemplate.java:122) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1573) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1511) ... 44 more 原因： spring版本过低，spring-data-redis采用了新的构造函数。 解决方案：升级spring版本指4.2.1以上","categories":[{"name":"redis","slug":"redis","permalink":"https://minichou.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://minichou.github.io/tags/redis/"},{"name":"sentinel","slug":"sentinel","permalink":"https://minichou.github.io/tags/sentinel/"},{"name":"spring-data-redis","slug":"spring-data-redis","permalink":"https://minichou.github.io/tags/spring-data-redis/"}]},{"title":"hexo添加打赏功能","slug":"hexo添加打赏功能","date":"2015-09-21T09:39:02.000Z","updated":"2017-03-29T01:44:37.706Z","comments":true,"path":"2015/09/21/hexo添加打赏功能/","link":"","permalink":"https://minichou.github.io/2015/09/21/hexo添加打赏功能/","excerpt":"本文将介绍如何在hexo中添加打赏功能 第一步：创建打赏html代码文件首先咱们在主题下layout/commmon文件里，创建一个名叫：donate.ejs的文件在里面输入:","text":"本文将介绍如何在hexo中添加打赏功能 第一步：创建打赏html代码文件首先咱们在主题下layout/commmon文件里，创建一个名叫：donate.ejs的文件在里面输入:12345678910111213141516171819202122&lt;!-- 添加捐赠图标 --&gt;&lt;div class=\"post-donate\" style=\"margin-bottom: 30px;margin-top: 10px;\"&gt; &lt;div id=\"donate_board\" class=\"donate_bar center\"&gt; &lt;a id=\"btn_donate\" class=\"btn_donate\" href=\"javascript:;\" title=\"donate\"&gt;&lt;/a&gt; &lt;span class=\"donate_txt\"&gt; &lt;%=theme.donate_message%&gt; &lt;/span&gt; &lt;br&gt; &lt;/div&gt; &lt;div id=\"donate_guide\" class=\"donate_bar donate_bar2 center hidden\"&gt; &lt;img src=\"/css/images/alipay.jpg\" id=\"weixin\" title=\"alipay doante\" alt=\"alipay doante\"&gt; &lt;img src=\"/css/images/wechatpay.jpg\" title=\"wechatpay donate\" id=\"zhifubao\" alt=\"echatpay donate\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $('#weixin').hover() document.getElementById('btn_donate').onclick = function () &#123; $('#donate_board').addClass('hidden'); $('#donate_guide').removeClass('hidden'); &#125; &lt;/script&gt;&lt;/div&gt; 其中，二维码图片只需放入主题中的source/css/images文件夹内，img的src设置src=”/css/images/alipay.jpg” 第二步：创建打赏css样式文件然后在主题source/css/_partial目录下创建一个相应的css文件donate.styl，输入以下内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374.donate_bar &#123; text-align: center; margin-top: 5%;&#125;.donate_bar2 &#123; z-index: 9999; text-align: center; top: 50%; left: 50%; width: 660px; height: 360px; margin: -180px 0 30px -330px; border-radius: 5px; border: solid 2px #666; background-color: #fff; box-shadow: 0 0 10px #666;&#125;.donate_bar a.btn_donate &#123; display: inline-block; width: 82px; height: 82px; margin-left: auto; margin-right: auto; background: url(/css/images/donate.gif) no-repeat; -webkit-transition: background 0s; -moz-transition: background 0s; -o-transition: background 0s; -ms-transition: background 0s; transition: background 0s&#125;.donate_bar a.btn_donate:hover &#123; background-position: 0 -82px&#125;.donate_bar .donate_txt &#123; display: block; color: #9d9d9d; font: 14px / 2 \"Microsoft Yahei\"&#125;.donate_bar.hidden &#123; display: none&#125;.post-donate &#123; margin-top: 80px;&#125;@media screen and (min-width: 559px) &#123; #donate_guide &#123; height: 210px; width: 420px; margin: 0 auto; &#125;&#125;@media screen and (max-width: 559px) &#123; #donate_guide &#123; height: 420px; width: 210px; margin: 0 auto; &#125;&#125;#donate_guide img &#123; height: 200px; width: 200px;&#125; 注意：以上赏字图片同样放入source/css/images文件夹内，背景图片引用如下方式：1background: url(/css/images/donate.gif) no-repeat; 或者采用外链https方式引用，否则浏览器警报不安全。 第三步：将创建的css文件和ejs文件整合到主题中首先修改主题source/css目录下的style.styl文件，在其中加入@import “_partial/donate”接着，在layout/commmon/article.ejs中，在1&lt;footer class=\"article-footer\"&gt; 前面加入：123&lt;div id=\"donate\" style=\"text-align:center\"&gt; &lt;%- partial('donate') %&gt;&lt;/div&gt; 如果你想自定义一个页面是否带有打赏的地方，则换成以下代码：12345&lt;% if(!index &amp;&amp; theme.donate &amp;&amp; (post.donate || post.donate == undefined))&#123; %&gt; &lt;div id=\"donate\" style=\"text-align:center\"&gt; &lt;%- partial('donate') %&gt; &lt;/div&gt;&lt;% &#125; %&gt; 第四步：编写配置文件在主题配置文件 _config.yml添加打赏相关配置，根据配置 控制文章是否开启打赏功能，还可以自定义设置打赏文案。例如：1234#是否开启打赏donate: true#打赏文案donate_message: 欣赏此文？求鼓励，求支持！ donate为false，则关闭打赏功能，如果要单独控制某篇文章，则donate为true的情况下，新建文章时，只需要在该篇文章上添加 donate: false即可。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://minichou.github.io/categories/杂谈/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://minichou.github.io/tags/hexo/"},{"name":"打赏","slug":"打赏","permalink":"https://minichou.github.io/tags/打赏/"}]}]}